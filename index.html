<!DOCTYPE html>
<html lang="en-us">

	<head>
		<meta charset="utf-8">
		<title>Sudoku</title>
		<style type="text/css">
			body {
				background-color: #222;
			}

			div {
				box-sizing: border-box;
			}

			#board {
				width: 98vmin;
				height: 98vmin;
				position: absolute;
				margin: auto;
				top: 0;
				right: 0;
				bottom: 0;
				left: 0;

				font-family: Arial, Helvetica, sans-serif;
				font-weight: bold;
				text-align: center;
				color: #0C0;

				display: flex;
				flex-flow: row wrap;
				justify-content: space-around;
			}

			.quadrant {
				width: 33.333%;
				height: 33.333%;

				display: flex;
				flex-flow: row wrap;
				justify-content: space-around;

				border-width: 0.4vmin;
				border-style: solid;
				border-color: #666;

				background-color: #666;
			}

			.cell {
				width: 33.333%;
				height: 33.333%;

				background-color: #333;

				border-width: 0.2vmin;
				border-style: solid;
				border-color: #666;

				font-size: 7vmin;
			}

			.notes {
				height: 15%;
				font-size: 2vmin;
			}
		</style>
	</head>

	<body>
		<div id="board"></div>
		<!-- Attach game to this element via JS html manipulation -->

		<script>
			/***************************************************************************
			 * Executable Logic, everything else is a function definition
			 ***************************************************************************
			 */

			let totalRecursions = 0;
			(function () {
				console.log("Sudoku")
				generateHtml()
				attachInputListeners()
				solveBoard()
			})()

			/***************************************************************************
			 * Make the HTML DOM for the board's UI
			 ***************************************************************************
			 */
			function generateHtml() {
				let html = ''
				for (let quadrant = 0; quadrant < 9; quadrant++) {
					html += `<div class="quadrant ${quadrant}">`
					let [xSet, ySet] = getCoordinatesOfQuadrant(quadrant)
					for (const x of xSet) {
						for (const y of ySet) {
							html += `<div class="cell">
							<div class="number" contenteditable="true" id="${x}${y}"></div>
							<div class="notes" contenteditable="true" id="notes${x}${y}"></div>
							</div>`
						}
					}
					html += `</div>`
				}
				document.getElementById('board').innerHTML = html
			}


			/***************************************************************************
			 * The below code deals with validating the sudoku board during human play
			 ***************************************************************************
			 */

			function attachInputListeners() {
				for (let i = 0; i < 9; i++) {
					for (let j = 0; j < 9; j++) {
						const cell = document.getElementById(`${i}${j}`)
						cell.addEventListener("input", cellInputCb)
					}
				}
			}

			function cellInputCb() {
				let capture
				if (!this.innerText.match(/^[0-9]$/)) {
					if (capture = this.innerText.match(/([0-9])/)) {
						this.innerText = capture[1]
					}
					else {
						this.innerText = ''
					}
				}
				validateBoard()
			}

			/**
			 * Function to scan every cell and validate against sudoku's game rules
			 * @return true if the board is fine or false if not
			 */
			function validateBoard() {
				resetValidation()

				const validRowsAndColumns = validateRowsAndColumns()

				const validQuadrants = validateQuadrants()

				return validRowsAndColumns && validQuadrants
			}

			function validateQuadrants() {
				let valid = true
				for (let i = 0; i < 9; i++) {
					const quadrant = document.getElementsByClassName(`quadrant ${i}`)[0]
					let seen = {}
					for (let pass = 1; pass <= 2; pass++) {
						for (const cellParent of quadrant.children) {
							const cell = cellParent.getElementsByClassName('number')[0]
							const number = cell.innerText
							if (number) {
								if (pass == 1 && seen[number] || pass == 2 && seen[number] > 1) {
									markCellValid(cell, false)
									valid = false
								}
								seen[number] ? seen[number]++ : seen[number] = 1
							}
						}
					}
				}
				return valid
			}

			function validateRowsAndColumns() {
				let valid = true

				for (const ltr of [true, false]) { // Cycle left to right or row by row, then top to bottom or through each column
					for (let i = 0; i < 9; i++) {
						let seen = {}
						for (let pass = 1; pass <= 2; pass++) {
							for (let j = 0; j < 9; j++) {
								const cellId = ltr ? `${i}${j}` : `${j}${i}`
								const cell = document.getElementById(cellId);
								const number = cell.innerText

								if (number) {
									if (pass == 1 && seen[number] || pass == 2 && seen[number] > 1) {
										markCellValid(cell, false)
										valid = false
									}
									seen[number] ? seen[number]++ : seen[number] = 1
								}
							}
						}
					}
				}
				return valid
			}

			function resetValidation() {
				for (let i = 0; i < 9; i++) {
					for (let j = 0; j < 9; j++) {
						markCellValid(document.getElementById(`${i}${j}`), true)
					}
				}
			}

			function resetBoardUI() {
				for (let i = 0; i < 9; i++) {
					for (let j = 0; j < 9; j++) {
						document.getElementById(`${i}${j}`).innerText = ''
						document.getElementById(`notes${i}${j}`).innerText = ''
					}
				}
			}

			function markCellValid(cell, valid) {
				if (valid) {
					cell.style.color = ''
				}
				else {
					cell.style.color = '#A00'
				}
			}


			/***************************************************************************
			 * All of the below code deals with solving sudoku boards
			 ***************************************************************************
			 */
			async function solveBoard() {
				// Each cell in this board is a hash of numbers tracking whether they're invalid (true) or valid (false/undefined)
				// as well as tracking the number actually written in the cell, if there is one
				// Example of a cell containing the number 2 which is valid, while 1 would be invalid for this cell:
				// Ex: { 1: true, 2: true, 3: false, number: 2 }
				const board = [
					[{}, {}, {}, {}, {}, {}, {}, {}, {}],
					[{}, {}, {}, {}, {}, {}, {}, {}, {}],
					[{}, {}, {}, {}, {}, {}, {}, {}, {}],
					[{}, {}, {}, {}, {}, {}, {}, {}, {}],
					[{}, {}, {}, {}, {}, {}, {}, {}, {}],
					[{}, {}, {}, {}, {}, {}, {}, {}, {}],
					[{}, {}, {}, {}, {}, {}, {}, {}, {}],
					[{}, {}, {}, {}, {}, {}, {}, {}, {}],
					[{}, {}, {}, {}, {}, {}, {}, {}, {}],
				]
				board.counts = [null, 0, 0, 0, 0, 0, 0, 0, 0, 0] // The times each number appears on the board. The 0 index is ignored.
				const solution = await recursivelySolveBoard(board)
				outputBoardToUI(solution)
				console.log("Total Recursions: ", totalRecursions)
			}

			async function recursivelySolveBoard(board) {
				totalRecursions += 1
				if (!solutionPossible(board)) return false

				const number = pickNumber(board.counts)
				if (!number) return board // solved

				// Find all valid cell coordinates
				let goodCells = []
				for (let i = 0; i < 9; i++) {
					for (let j = 0; j < 9; j++) {
						const cell = board[i][j]
						if (!cell[number] && !cell.number) {
							goodCells.push([i, j])
						}
					}
				}

				if (!goodCells.length) return false // no viable cells means dead end

				shuffleArray(goodCells)

				for (const goodCell of goodCells) {
					const newBoard = deepCopyBoard(board)
					await writeNumber(newBoard, number, goodCell[0], goodCell[1])
					const answer = await recursivelySolveBoard(newBoard)
					if (answer) return answer // solved
				}

				return false // all viable cells led to a dead end
			}

			// Based on filled numbers and valid numbers, ensure each row/col/quad can contain 1-9
			function solutionPossible(board) {
				for (let i = 0; i < 9; i++) {
					const rowNums = []
					const colNums = []
					for (let j = 0; j < 9; j++) {
						if (board[i][j].number) rowNums[board[i][j].number] = true
						if (board[j][i].number) colNums[board[j][i].number] = true
						for (let number = 1; number <= 9; number++) {
							rowNums[number] = rowNums[number] || !board[i][j][number]
							colNums[number] = colNums[number] || !board[j][i][number]
						}
					}
					for (let number = 1; number <= 9; number++) {
						if (!rowNums[number]) return false
						if (!colNums[number]) return false
					}
				}

				for (let quadrant = 0; quadrant < 9; quadrant++) {
					const [xSet, ySet] = getCoordinatesOfQuadrant(quadrant)
					const quadNums = []
					for (const x of xSet) {
						for (const y of ySet) {
							if (board[x][y].number) quadNums[board[x][y].number] = true
							for (let number = 1; number <= 9; number++) {
								quadNums[number] = quadNums[number] || !board[x][y][number]
							}
						}
					}
					for (let number = 1; number <= 9; number++) {
						if (!quadNums[number]) return false
					}
				}

				return true
			}

			function outputBoardToUI(board) {
				for (let i = 0; i < 9; i++) {
					for (let j = 0; j < 9; j++) {
						const cell = document.getElementById(`${i}${j}`)
						if (board[i][j].number) {
							cell.innerText = board[i][j].number
						}
						else {
							cell.innerText = ''
						}
						let notes = ''
						for (let number = 1; number <= 9; number++) {
							if (!board[i][j][number]) {
								notes += number
							}
						}
						document.getElementById(`notes${i}${j}`).innerText = notes
					}
				}
			}

			function deepCopyBoard(oldBoard) {
				const newBoard = [
					[{}, {}, {}, {}, {}, {}, {}, {}, {}],
					[{}, {}, {}, {}, {}, {}, {}, {}, {}],
					[{}, {}, {}, {}, {}, {}, {}, {}, {}],
					[{}, {}, {}, {}, {}, {}, {}, {}, {}],
					[{}, {}, {}, {}, {}, {}, {}, {}, {}],
					[{}, {}, {}, {}, {}, {}, {}, {}, {}],
					[{}, {}, {}, {}, {}, {}, {}, {}, {}],
					[{}, {}, {}, {}, {}, {}, {}, {}, {}],
					[{}, {}, {}, {}, {}, {}, {}, {}, {}],
				]
				newBoard.counts = [null, 0, 0, 0, 0, 0, 0, 0, 0, 0]

				for (let i = 0; i < 9; i++) {
					for (let j = 0; j < 9; j++) {
						for (let number = 1; number <= 9; number++) {
							if (oldBoard[i][j][number]) newBoard[i][j][number] = true
						}
						if (oldBoard[i][j].number) newBoard[i][j].number = oldBoard[i][j].number
					}
				}

				for (let number = 1; number <= 9; number++) {
					newBoard.counts[number] = oldBoard.counts[number]
				}

				return newBoard
			}

			/**
			 * Find a good number to try to fill next given the counts of each number
			 * Will return 0 if no number is possible
			 */
			function pickNumber(counts) {
				let pick = { number: 0, count: -1 }
				for (let number = 1; number <= 9; number++) {
					if (counts[number] < 9) {
						if (counts[number] > pick.count) {
							pick.number = number
							pick.count = counts[number]
						}
						else if (counts[number] == pick.count && Math.random() > 0.7) {
							pick.number = number
						}
					}
				}

				return pick.number
			}

			/**
			 * Simply write a number to a board, no validation prior to writing
			 * Will update board counts and number-valid hash
			 */
			function writeNumber(board, number, x, y) {
				let xset = getQuadrant(x)
				let yset = getQuadrant(y)
				let cell = board[x][y]

				cell.number = number
				for (let i = 0; i < 9; i++) {
					board[x][i][number] = true
					board[i][y][number] = true
					board[x][y][i + 1] = true
				}
				for (const i of xset) {
					for (const j of yset) {
						board[i][j][number] = true
					}
				}
				board.counts[number] += 1

				outputBoardToUI(board)
				return new Promise((resolve) => setTimeout(resolve, 0))
			}

			/**
			 * Given a coordinate return a set of cordinates for every cell in it's quadrant
			 * @return Given c=1 then return [0,1,2]
			 */
			function getQuadrant(coordinate) {
				let quadrant = [6, 7, 8]

				if (coordinate < 3) {
					quadrant = [0, 1, 2]
				}
				else if (coordinate < 6) {
					quadrant = [3, 4, 5]
				}

				return quadrant
			}

			function getCoordinatesOfQuadrant(quadrant) {
				const quadrantY = quadrant % 3
				const quadrantX = Math.floor(quadrant / 3)

				return [getCoordLine(quadrantX), getCoordLine(quadrantY)]

				function getCoordLine(sector) {
					switch (sector) {
					case 0:
						return [0, 1, 2]
					case 1:
						return [3, 4, 5]
					case 2:
						return [6, 7, 8]
					}
				}
			}

			function shuffleArray(a) {
				for (let i = a.length - 1; i > 0; i--) {
					const j = Math.floor(Math.random() * (i + 1));
					[a[i], a[j]] = [a[j], a[i]]
				}
				return a
			}
		</script>
	</body>

</html>
