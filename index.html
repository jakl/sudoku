<!DOCTYPE html>
<html lang="en-us">

	<head>
		<meta charset="utf-8">
		<title>Sudoku</title>
		<style type="text/css">
			body {
				background-color: #222;
			}

			div {
				box-sizing: border-box;
			}

			#board {
				width: 98vmin;
				height: 98vmin;
				position: absolute;
				margin: auto;
				top: 0;
				right: 0;
				bottom: 0;
				left: 0;

				font-family: Arial, Helvetica, sans-serif;
				font-weight: bold;
				text-align: center;
				color: #0C0;

				display: flex;
				flex-flow: row wrap;
				justify-content: space-around;
			}

			.quadrant {
				width: 33.333%;
				height: 33.333%;

				display: flex;
				flex-flow: row wrap;
				justify-content: space-around;

				border-width: 0.4vmin;
				border-style: solid;
				border-color: #666;

				background-color: #666;
			}

			.cell {
				width: 33.333%;
				height: 33.333%;

				background-color: #333;

				border-width: 0.2vmin;
				border-style: solid;
				border-color: #666;

				font-size: 7vmin;
			}

			.notes {
				height: 15%;
				font-size: 2vmin;
			}
		</style>
	</head>

	<body>
		<div id="board"></div> <!-- Attach game to this element via JS html manipulation -->

		<script>
			/***************************************************************************
			 * Executable Logic, everything else is a function definition
			 ***************************************************************************
			 */

			let outputCellCounter = 0;;
			(function () {
				console.log("Sudoku")
				generateHtml()
				attachInputListeners()
				solveBoard()
			})()

			/***************************************************************************
			 * Make the HTML DOM for the board's UI
			 ***************************************************************************
			 */
			function generateHtml() {
				let html = ''
				for (let quadrant = 0; quadrant < 9; quadrant++) {
					html += `<div class="quadrant ${quadrant}">`
					let [xSet, ySet] = getCoordinatesOfQuadrant(quadrant)
					for (let x of xSet) {
						for (let y of ySet) {
							html += `<div class="cell">
							<div class="number" contenteditable="true" id="${x}${y}"></div>
							<div class="notes" contenteditable="true" id="notes${x}${y}"></div>
							</div>`
						}
					}
					html += `</div>`
				}
				document.getElementById('board').innerHTML = html
			}


			/***************************************************************************
			 * All of the below code deals with generating and validating sudoku boards
			 ***************************************************************************
			 */

			function generateRandomValidBoard() {
				let generated = 1
				generateRandomBoard()
				while (!validateBoard()) {
					resetBoard()
					generateRandomBoard()
					generated += 1
				}
				console.log(generated, 'boards generated before finding a valid one')

				let cellsFilled = 0
				for (let cell of document.getElementsByClassName('cell')) {
					if (cell.innerText) {
						cellsFilled += 1
					}
				}
				console.log(cellsFilled, 'cells filled')
			}

			function generateRandomBoard() {
				for (let i = 0; i < 9; i++) {
					for (let j = 0; j < 9; j++) {
						const cell = document.getElementById(`${i}${j}`);
						if (Math.random() > 0.7) cell.innerText = Math.ceil(Math.random() * 9);
					}
				}
			}

			function attachInputListeners() {
				for (let i = 0; i < 9; i++) {
					for (let j = 0; j < 9; j++) {
						const cell = document.getElementById(`${i}${j}`);
						cell.addEventListener("input", cellInputCb)
					}
				}
			}

			function cellInputCb() {
				let capture;
				if (!this.innerText.match(/^[0-9]$/)) {
					if (capture = this.innerText.match(/([0-9])/)) {
						this.innerText = capture[1]
					}
					else {
						this.innerText = ''
					}
				}
				validateBoard()
			}

			/**
			 * Function to scan every cell and validate against sudoku's game rules
			 * @return true if the board is fine or false if not
			 */
			function validateBoard() {
				resetValidation()

				const validRowsAndColumns = validateRowsAndColumns()

				const validQuadrants = validateQuadrants()

				return validRowsAndColumns && validQuadrants
			}

			function validateQuadrants() {
				let valid = true
				for (let i = 0; i < 9; i++) {
					const quadrant = document.getElementsByClassName(`quadrant ${i}`)[0]
					let seen = {}
					for (let pass = 1; pass <= 2; pass++) {
						for (let cell of quadrant.children) {
							const number = cell.innerText
							if (number) {
								if (pass == 1 && seen[number] || pass == 2 && seen[number] > 1) {
									markCellValid(cell, false)
									valid = false
								}
								seen[number] ? seen[number]++ : seen[number] = 1
							}
						}
					}
				}
				return valid
			}

			function validateRowsAndColumns() {
				let valid = true

				for (let ltr of [true, false]) { // Cycle left to right or row by row, then top to bottom or through each column
					for (let i = 0; i < 9; i++) {
						let seen = {}
						for (let pass = 1; pass <= 2; pass++) {
							for (let j = 0; j < 9; j++) {
								const cellId = ltr ? `${i}${j}` : `${j}${i}`
								const cell = document.getElementById(cellId);
								const number = cell.innerText

								if (number) {
									if (pass == 1 && seen[number] || pass == 2 && seen[number] > 1) {
										markCellValid(cell, false)
										valid = false
									}
									seen[number] ? seen[number]++ : seen[number] = 1
								}
							}
						}
					}
				}
				return valid
			}

			function resetValidation() {
				for (let i = 0; i < 9; i++) {
					for (let j = 0; j < 9; j++) {
						markCellValid(document.getElementById(`${i}${j}`), true)
					}
				}
			}

			function resetBoard() {
				for (let i = 0; i < 9; i++) {
					for (let j = 0; j < 9; j++) {
						document.getElementById(`${i}${j}`).innerText = ''
					}
				}
			}

			function markCellValid(cell, valid) {
				if (valid) {
					cell.style.color = ''
				}
				else {
					cell.style.color = '#A00'
				}
			}


			/***************************************************************************
			 * All of the below code deals with solving sudoku boards
			 ***************************************************************************
			 */
			function solveBoard() {
				// Each cell in this board is a hash of numbers tracking whether they're invalid (true) or valid (false)
				// as well as tracking the number written in the cell if any
				// Example of a cell containing the number 2 which is valid, while 1 would be invalid for this cell:
				// Ex: { 1: true, 2: false, number: 2 }
				const board = [
					[{}, {}, {}, {}, {}, {}, {}, {}, {}],
					[{}, {}, {}, {}, {}, {}, {}, {}, {}],
					[{}, {}, {}, {}, {}, {}, {}, {}, {}],
					[{}, {}, {}, {}, {}, {}, {}, {}, {}],
					[{}, {}, {}, {}, {}, {}, {}, {}, {}],
					[{}, {}, {}, {}, {}, {}, {}, {}, {}],
					[{}, {}, {}, {}, {}, {}, {}, {}, {}],
					[{}, {}, {}, {}, {}, {}, {}, {}, {}],
					[{}, {}, {}, {}, {}, {}, {}, {}, {}],
				]
				board.counts = [null, 0, 0, 0, 0, 0, 0, 0, 0, 0] // The times each number appears on the board. The 0 index is ignored.
				//for (let number = 1; number <= 9; number++) fillNextNumber(board, number) // Fill one of each number to start
				const solvedBoard = recursivelySolveBoard(board)
				//outputBoardToUI(solvedBoard)
			}

			async function recursivelySolveBoard(board) {
				const number = pickNumber(board.counts)
				if (!number) {
					return board // solved
				}

				// Find all valid cell coordinates
				let goodCells = []
				for (let i = 0; i < 9; i++) {
					for (let j = 0; j < 9; j++) {
						const cell = board[i][j]
						if (!cell[number] && !cell.number) {
							goodCells.push([i, j])
						}
					}
				}

				if (!goodCells.length) return false // no viable cells means dead end

				const newBoard = deepCopyBoard(board)

				for (const goodCell of goodCells) {
					await writeNumber(newBoard, number, goodCell[0], goodCell[1])
					const answer = recursivelySolveBoard(newBoard)
					if (answer) {
						return answer // solved
					} // else dead end
				}

				return false // all viable cells led to a dead end
			}

			function outputBoardToUI(board) {
				for (let i = 0; i < 9; i++) {
					for (let j = 0; j < 9; j++) {
						const cell = document.getElementById(`${i}${j}`);
						if (board[i][j].number) {
							cell.innerText = board[i][j].number
						}
						else {
							cell.innerText = ''
						}
						let notes = ''
						for (let number = 1; number <= 9; number++) {
							if (!board[i][j][number]) {
								notes += number
							}
						}
						document.getElementById(`notes${i}${j}`).innerText = notes
					}
				}
			}

			function deepCopyBoard(oldBoard) {
				const newBoard = [
					[{}, {}, {}, {}, {}, {}, {}, {}, {}],
					[{}, {}, {}, {}, {}, {}, {}, {}, {}],
					[{}, {}, {}, {}, {}, {}, {}, {}, {}],
					[{}, {}, {}, {}, {}, {}, {}, {}, {}],
					[{}, {}, {}, {}, {}, {}, {}, {}, {}],
					[{}, {}, {}, {}, {}, {}, {}, {}, {}],
					[{}, {}, {}, {}, {}, {}, {}, {}, {}],
					[{}, {}, {}, {}, {}, {}, {}, {}, {}],
					[{}, {}, {}, {}, {}, {}, {}, {}, {}],
				]
				newBoard.counts = [null, 0, 0, 0, 0, 0, 0, 0, 0, 0]

				for (let i = 0; i < 9; i++) {
					for (let j = 0; j < 9; j++) {
						for (let number = 1; number <= 9; number++) {
							if (oldBoard[i][j][number]) newBoard[i][j][number] = true
						}
						if (oldBoard[i][j].number) newBoard[i][j].number = oldBoard[i][j].number
					}
				}

				for (let number = 1; number <= 9; number++) {
					newBoard.counts[number] = oldBoard.counts[number]
				}

				return newBoard
			}

			/**
			 * Pick a good number and try to fill it for a given board
			 */
			function fillNextNumber(board, optionalNumber) {
				let number = optionalNumber || pickNumber(board.counts)
				if (!number) {
					console.log("Stopping cause no numbers left")
					return false
				}
				let [x, y] = findValidCoordinatesForNumber(board, number)
				if (x == -1 || y == -1) {
					console.log("Stopping cause can't find valid coordinates")
					return false
				}
				writeNumber(board, number, x, y)
				return true
			}

			/**
			 * Find a good number to try to fill next given the counts of each number
			 * Will return 0 if no number is possible
			 */
			function pickNumber(counts) {
				let pick = { number: 0, count: -1 }
				for (let number = 1; number <= 9; number++) {
					if (counts[number] < 9) {
						if (counts[number] > pick.count) {
							pick.number = number
							pick.count = counts[number]
						}
						else if (counts[number] == pick.count && Math.random() > 0.7) {
							pick.number = number
						}
					}
				}

				return pick.number
			}

			/**
			 * Simply write a number to a board, no validation prior to writing
			 * Will update board counts and number-valid hash
			 */
			function writeNumber(board, number, x, y) {
				let xset = getQuadrant(x)
				let yset = getQuadrant(y)
				let cell = board[x][y]

				cell.number = number
				for (let i = 0; i < 9; i++) {
					board[x][i][number] = true
					board[i][y][number] = true
				}
				for (let i of xset) {
					for (let j of yset) {
						board[i][j][number] = true
					}
				}
				board.counts[number] += 1

				outputBoardToUI(board)
				return new Promise((resolve) => setTimeout(resolve, 1000))
			}

			// Output just one cell to the UI
			function outputBoardDelayed(board) {
				setTimeout(() => {
					outputBoardToUI(board)
				}, outputCellCounter += 300)
			}

			// returns [-1, -1] when no coordinates are found
			function findValidCoordinatesForNumber(board, number) {
				let x = Math.floor(Math.random() * 9)
				let y = Math.floor(Math.random() * 9)
				let iterations = 0
				while (board[x][y][number] || board[x][y].number) {
					x = Math.floor(Math.random() * 9)
					y = Math.floor(Math.random() * 9)
					if (iterations++ > 1000000) return [-1, -1]
				}
				return [x, y]
			}

			/**
			 * Given a coordinate return a set of cordinates for every cell in it's quadrant
			 * @return Given c=1 then return [0,1,2]
			 */
			function getQuadrant(coordinate) {
				let quadrant = [6, 7, 8]

				if (coordinate < 3) {
					quadrant = [0, 1, 2]
				}
				else if (coordinate < 6) {
					quadrant = [3, 4, 5]
				}

				return quadrant
			}

			function getCoordinatesOfQuadrant(quadrant) {
				const quadrantY = quadrant % 3
				const quadrantX = Math.floor(quadrant / 3)

				return [getCoordLine(quadrantX), getCoordLine(quadrantY)]

				function getCoordLine(sector) {
					switch (sector) {
					case 0:
						return [0, 1, 2]
					case 1:
						return [3, 4, 5]
					case 2:
						return [6, 7, 8]
					}
				}
			}
		</script>
	</body>

</html>
